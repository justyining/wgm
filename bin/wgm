#!/usr/bin/env node

/**
 * wgm - Simplified WireGuard Peer Management Tool
 *
 * A lightweight CLI tool for managing WireGuard peers with interactive prompts.
 */

import { execSync, spawn } from 'child_process';
import inquirer from 'inquirer';
import QRCode from 'qrcode';
import { readFileSync, writeFileSync, copyFileSync, existsSync, mkdirSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join, basename } from 'path';

/**
 * Parse WireGuard config file (handles multiple [Peer] sections with comments)
 * @param {string} content - Config file content
 * @returns {Object} - Parsed config with unique keys for each peer
 */
function parseWireGuardConfig(content) {
  const lines = content.split('\n');
  const config = {};
  let currentSection = null;
  let peerIndex = 0;
  let pendingPeerName = null;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    if (!trimmed) continue;

    // Comment line - might be a peer name
    if (trimmed.startsWith('#')) {
      const comment = trimmed.slice(1).trim();
      // Check if next line is [Peer]
      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';
      if (nextLine === '[Peer]') {
        pendingPeerName = comment;
      }
      continue;
    }

    // Section header
    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
      const sectionName = trimmed.slice(1, -1);
      if (sectionName === 'Peer') {
        // Use comment as peer name if available, otherwise use index
        const peerName = pendingPeerName || `unnamed-${peerIndex}`;
        currentSection = `Peer #${peerName}`;
        peerIndex++;
        pendingPeerName = null;
      } else {
        currentSection = sectionName;
      }
      if (!config[currentSection]) {
        config[currentSection] = {};
      }
      continue;
    }

    // Key = Value
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex > 0 && currentSection) {
      const key = trimmed.slice(0, eqIndex).trim();
      const value = trimmed.slice(eqIndex + 1).trim();
      config[currentSection][key] = value;
    }
  }

  return config;
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Check for dry-run/test mode
const DRY_RUN = process.argv.includes('--dry-run') || process.argv.includes('--test');

// Check for custom config file
const configArgIndex = process.argv.indexOf('--config');
const CUSTOM_CONFIG = configArgIndex !== -1 && process.argv[configArgIndex + 1] ? process.argv[configArgIndex + 1] : null;

// Dry-run requires --config
if (DRY_RUN && !CUSTOM_CONFIG) {
  console.log('[ERROR] --dry-run requires --config <path>');
  console.log('Usage: wgm --dry-run --config /path/to/wg.conf add');
  process.exit(1);
}

// Auto-elevation: re-run with sudo if not root (skip in dry-run mode)
if (!DRY_RUN && process.getuid && process.getuid() !== 0) {
  console.log('[INFO] Requesting sudo privileges...');
  const args = process.argv.slice(2);
  // Use absolute path to ensure same Node.js version
  const nodePath = process.execPath;
  const child = spawn('sudo', ['-E', nodePath, __filename, ...args], {
    stdio: 'inherit',
    env: process.env
  });
  child.on('exit', (code) => process.exit(code));
  // Stop execution here, let the sudo process take over
  await new Promise(() => {});
}

// Use custom config or default
const CONFIG_DIR = CUSTOM_CONFIG ? dirname(CUSTOM_CONFIG) : '/etc/wireguard';

let INTERFACE = null;
let CONFIG_PATH = null;

/**
 * Get WireGuard interface from args, env, or auto-detect
 * @returns {Promise<string>} - Interface name
 */
async function getInterface() {
  // Check CLI arg: -i <name>
  const argIndex = process.argv.indexOf('-i');
  if (argIndex !== -1 && process.argv[argIndex + 1]) {
    return process.argv[argIndex + 1];
  }

  // List available configs
  try {
    const output = execSync(`ls ${CONFIG_DIR}/*.conf 2>/dev/null | xargs -n1 basename`, { encoding: 'utf-8' });
    const configs = output.trim().split('\n').filter(c => c && c.endsWith('.conf'));
    if (configs.length === 0) {
      console.log('[ERROR] No WireGuard configs found in ' + CONFIG_DIR);
      process.exit(1);
    }
    const names = configs.map(c => c.replace('.conf', ''));
    if (names.length === 1) {
      return names[0];
    }
    const { interface: selected } = await inquirer.prompt([{
      type: 'list',
      name: 'interface',
      message: 'Select WireGuard interface:',
      choices: names
    }]);
    return selected;
  } catch {
    console.log('[ERROR] Cannot read ' + CONFIG_DIR);
    process.exit(1);
  }
}

/**
 * Initialize interface and config path
 */
async function init() {
  if (!INTERFACE) {
    // Use custom config file if specified
    if (CUSTOM_CONFIG) {
      CONFIG_PATH = CUSTOM_CONFIG;
      INTERFACE = 'custom';
      console.log(`[INFO] Using custom config: ${CUSTOM_CONFIG}`);
      return;
    }
    INTERFACE = await getInterface();
    CONFIG_PATH = join(CONFIG_DIR, `${INTERFACE}.conf`);
  }
}

/**
 * Validate WireGuard public key format
 * @param {string} key - Public key to validate
 * @returns {boolean} - Whether the key is valid
 */
function validateKey(key) {
  return /^[A-Za-z0-9+/]{43}=?$/.test(key.trim());
}

/**
 * Validate peer name
 * @param {string} name - Peer name to validate
 * @returns {boolean|string} - True if valid, error message otherwise
 */
function validatePeerName(name) {
  if (!name || name.length === 0) {
    return 'Name cannot be empty';
  }
  if (name.length > 100) {
    return 'Name too long (max 100 characters)';
  }
  if (/[<>:"|?*\n\r]/.test(name)) {
    return 'Name contains invalid characters';
  }
  if (name.startsWith('#')) {
    return 'Name cannot start with #';
  }
  if (name.includes('Peer #')) {
    return 'Name cannot contain "Peer #"';
  }
  return true;
}

/**
 * Validate CIDR notation
 * @param {string} cidr - CIDR string to validate (e.g., "10.0.0.0/24")
 * @returns {boolean|string} - True if valid, error message otherwise
 */
function validateCIDR(cidr) {
  if (!cidr || cidr.length === 0) {
    return 'CIDR cannot be empty';
  }
  const parts = cidr.split(',').map(s => s.trim());
  for (const part of parts) {
    const match = part.match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\/(\d{1,2})$/);
    if (!match) {
      return `Invalid CIDR format: ${part}`;
    }
    const [, octet1, octet2, octet3, octet4, prefix] = match;
    const octets = [octet1, octet2, octet3, octet4].map(Number);
    const prefixNum = Number(prefix);

    for (const octet of octets) {
      if (octet > 255) {
        return `Invalid octet (>255) in: ${part}`;
      }
    }
    if (prefixNum > 32) {
      return `Invalid prefix length (>32) in: ${part}`;
    }
  }
  return true;
}

/**
 * Get server's public key from config
 * @returns {string|null} - Server public key or null if not found
 */
function getServerPublicKey() {
  try {
    const config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
    const privKey = config.Interface && config.Interface.PrivateKey;
    if (privKey) {
      if (DRY_RUN) {
        // In dry-run mode, return simulated public key
        return 'SIMULATED_SERVER_PUBLIC_KEY_FOR_DRY_RUN';
      }
      return execSync(`echo "${privKey}" | wg pubkey`, { encoding: 'utf-8' }).trim();
    }
  } catch (e) {
    return null;
  }
  return null;
}

/**
 * Get server endpoint (IP:Port)
 * @returns {string|null} - Endpoint string or null
 */
function getEndpoint() {
  try {
    const config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
    const port = (config.Interface && config.Interface.ListenPort) || '51820';
    try {
      const ip = execSync('curl -s ifconfig.me', { encoding: 'utf-8', timeout: 3000 }).trim();
      return `${ip}:${port}`;
    } catch {
      return `YOUR_SERVER_IP:${port}`;
    }
  } catch {
    return null;
  }
}

/**
 * Show initialization hint for creating WireGuard config
 */
function showInitHint() {
  console.log('\n[INFO] WireGuard config not found or empty: ' + CONFIG_PATH);
  console.log('[HINT] Create a config with the following steps:\n');
  console.log('1. Generate server keys:');
  console.log('   wg genkey | tee privatekey | wg pubkey > publickey');
  console.log('\n2. Create config file:');
  console.log(`   sudo mkdir -p ${CONFIG_DIR}`);
  console.log(`   sudo tee ${CONFIG_PATH} << 'EOF'`);
  console.log('[Interface]');
  console.log('Address = 10.0.0.1/24');
  console.log('ListenPort = 51820');
  console.log('PrivateKey = YOUR_SERVER_PRIVATE_KEY_HERE');
  console.log('EOF');
  console.log('\n3. Set permissions:');
  console.log(`   sudo chmod 600 ${CONFIG_PATH}`);
  console.log('\n4. Start WireGuard:');
  console.log(`   sudo wg-quick up ${INTERFACE || 'wg0'}`);
  console.log('');
}

/**
 * Get next available IP address from the configured network range
 * @returns {string|null} - Available IP with CIDR or null
 */
function getAvailableIP() {
  let config;
  try {
    config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (e) {
    if (e.code === 'ENOENT') {
      showInitHint();
    } else {
      console.log('[ERROR] Failed to read config: ' + e.message);
    }
    return null;
  }

  const network = config.Interface && config.Interface.Address;

  if (!network) {
    console.log('[ERROR] No Address found in [Interface] section of ' + CONFIG_PATH);
    console.log('[HINT] Ensure your config has: Address = 10.0.0.1/24');
    return null;
  }

  const [baseIp, cidr] = network.split('/');
  const cidrNum = parseInt(cidr, 10);

  if (isNaN(cidrNum) || cidrNum < 1 || cidrNum > 32) {
    console.log('[ERROR] Invalid CIDR: ' + cidr);
    return null;
  }

  // Convert IP to integer
  const ipToNum = (ip) => ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0);
  const numToIp = (num) => [
    (num >>> 24) & 255,
    (num >>> 16) & 255,
    (num >>> 8) & 255,
    num & 255
  ].join('.');

  const baseIpNum = ipToNum(baseIp);
  const mask = cidrNum === 0 ? 0 : (~0 << (32 - cidrNum)) >>> 0;
  const networkNum = baseIpNum & mask;

  // Calculate usable host range
  const totalHosts = Math.pow(2, 32 - cidrNum);
  if (cidrNum >= 31) {
    console.log('[ERROR] CIDR /31 and /32 have no usable host addresses');
    return null;
  }

  const firstUsable = networkNum + 1;  // Network address + 1
  const lastUsable = networkNum + totalHosts - 2;  // -2 for network and broadcast

  // Collect used IPs
  const used = new Set();
  for (const [key, val] of Object.entries(config)) {
    const allowedIPs = val.AllowedIPs || val.AllowedIps;
    if (key.startsWith('Peer') && allowedIPs) {
      const ip = allowedIPs.split('/')[0];
      const ipNum = ipToNum(ip);
      if (ipNum >= firstUsable && ipNum <= lastUsable) {
        used.add(ipNum);
      }
    }
  }

  // Find first available IP
  for (let ipNum = firstUsable; ipNum <= lastUsable; ipNum++) {
    if (!used.has(ipNum)) {
      return `${numToIp(ipNum)}/32`;
    }
  }
  console.log('[ERROR] No available IP addresses in range ' + numToIp(firstUsable) + ' - ' + numToIp(lastUsable));
  return null;
}

/**
 * Save configuration and reload WireGuard
 * @param {Object} config - Parsed INI config object
 */
function saveConfig(config) {
  // Build config content
  const sections = [];
  for (const [key, val] of Object.entries(config)) {
    if (key.startsWith('Peer #')) {
      // Peer name as comment, standard [Peer] section
      const peerName = key.replace('Peer #', '');
      sections.push(`# ${peerName}`);
      sections.push('[Peer]');
    } else {
      sections.push(`[${key}]`);
    }
    for (const [k, v] of Object.entries(val)) {
      sections.push(`${k} = ${v}`);
    }
    sections.push('');
  }
  // Create backup
  const backupDir = join(dirname(CONFIG_PATH), 'backups');
  try {
    mkdirSync(backupDir, { recursive: true, mode: 0o700 });
  } catch (e) {
    if (e.code !== 'EEXIST') throw e;
  }
  const backupPath = join(backupDir, `${basename(CONFIG_PATH)}.backup.${Date.now()}`);

  try {
    copyFileSync(CONFIG_PATH, backupPath);
    writeFileSync(CONFIG_PATH, sections.join('\n'));
  } catch (e) {
    console.log('[ERROR] Failed to save config:', e.message);
    console.log('[INFO] Backup available at:', backupPath);
    throw e;
  }

  // Reload WireGuard (skip in dry-run mode)
  if (DRY_RUN) {
    console.log('[DRY-RUN] Skipping WireGuard reload');
    return;
  }
  try {
    execSync(`wg syncconf ${INTERFACE} <(wg-quick strip ${INTERFACE})`, { shell: 'bash', stdio: 'pipe' });
  } catch (syncError) {
    console.log('[WARN] syncconf failed, attempting restart...');
    try {
      execSync(`wg-quick down ${INTERFACE} 2>/dev/null; wg-quick up ${INTERFACE}`, { stdio: 'inherit' });
    } catch (restartError) {
      console.log('[ERROR] Failed to reload WireGuard:', restartError.message);
      throw restartError;
    }
  }
}

/**
 * Add a new peer interactively
 */
async function addPeer() {
  await init();

  let config;
  try {
    config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (e) {
    if (e.code === 'ENOENT') {
      showInitHint();
    } else {
      console.log('[ERROR] Failed to read config: ' + e.message);
    }
    return;
  }

  // Prompt for peer name
  const { name } = await inquirer.prompt([{
    type: 'input',
    name: 'name',
    message: 'Peer name:',
    validate: validatePeerName
  }]);

  // Check for duplicate
  if (config[`Peer #${name}`]) {
    console.log(`[ERROR] Peer "${name}" already exists`);
    return;
  }

  // Choose key method
  const { method } = await inquirer.prompt([{
    type: 'list',
    name: 'method',
    message: 'Key generation method:',
    choices: [
      { name: 'I provide the client public key (recommended)', value: 'manual' },
      { name: 'Auto-generate key pair', value: 'auto' }
    ]
  }]);

  let publicKey, privateKey;
  if (method === 'manual') {
    console.log('\nOn the client device, run:');
    console.log('  wg genkey | tee privatekey | wg pubkey');
    console.log('Send the PUBLIC KEY to the server admin.\n');

    const { key } = await inquirer.prompt([{
      type: 'input',
      name: 'key',
      message: 'Paste client public key:',
      validate: input => validateKey(input) || 'Invalid key format (44 character base64)'
    }]);
    publicKey = key.trim();
  } else if (DRY_RUN) {
    // Simulate key generation in dry-run mode
    privateKey = 'SIMULATED_PRIVATE_KEY_FOR_DRY_RUN_ONLY';
    publicKey = 'SIMULATED_CLIENT_PUBLIC_KEY_FOR_DRY_RUN';
    console.log('[DRY-RUN] Using simulated keys');
  } else {
    privateKey = execSync('wg genkey', { encoding: 'utf-8' }).trim();
    publicKey = execSync(`echo "${privateKey}" | wg pubkey`, { encoding: 'utf-8' }).trim();
  }

  // Get available IP
  const ip = getAvailableIP();
  if (!ip) {
    console.log('[ERROR] Unable to get available IP');
    return;
  }
  console.log(`Assigned IP: ${ip}`);

  // Get server's VPN network for AllowedIPs
  let serverNetwork = '10.0.0.0/24';
  try {
    const config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
    if (config.Interface && config.Interface.Address) {
      const [baseIp, cidr] = config.Interface.Address.split('/');
      const prefix = baseIp.split('.').slice(0, 3).join('.');
      serverNetwork = `${prefix}.0/${cidr}`;
    }
  } catch {}

  const { allowedIPs } = await inquirer.prompt([{
    type: 'input',
    name: 'allowedIPs',
    message: 'AllowedIPs (traffic to route through VPN):',
    default: serverNetwork,
    validate: validateCIDR
  }]);

  // Save config
  config[`Peer #${name}`] = {
    PublicKey: publicKey,
    AllowedIPs: ip
  };
  saveConfig(config);
  console.log(`[OK] Peer "${name}" added successfully`);

  // Generate client config
  const serverPubKey = getServerPublicKey();
  const endpoint = getEndpoint();

  const clientConfig = `[Interface]
${privateKey ? `PrivateKey = ${privateKey}
` : '# PrivateKey = YOUR_PRIVATE_KEY_HERE\n'}Address = ${ip}

[Peer]
PublicKey = ${serverPubKey}
AllowedIPs = ${allowedIPs}
Endpoint = ${endpoint}
PersistentKeepalive = 25`;

  // Print client config to terminal
  console.log('\n========== Client Config ==========');
  console.log(clientConfig);
  console.log('===================================\n');

  // Generate QR code
  try {
    const qr = await QRCode.toString(clientConfig, { type: 'terminal', small: true });
    console.log('\n[QR] QR Code:');
    console.log(qr);
  } catch {}

  if (privateKey) {
    console.log('\n[WARN] Private key generated. Keep it safe!');
  }
}

/**
 * List all peers with their status
 */
async function listPeers() {
  await init();

  let config;
  try {
    config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (e) {
    if (e.code === 'ENOENT') {
      showInitHint();
    } else {
      console.log('[ERROR] Failed to read config: ' + e.message);
    }
    return;
  }

  console.log(`\n Peers on ${INTERFACE}:\n`);

  // Get online status
  let onlinePeers = new Set();
  try {
    const status = execSync(`wg show ${INTERFACE}`, { encoding: 'utf-8' });
    const matches = status.match(/peer: ([^\s]+)/g);
    onlinePeers = new Set(matches ? matches.map(p => p.replace('peer: ', '')) : []);
  } catch (e) {
    // WireGuard not running or interface not active
    if (process.env.DEBUG) console.log('[DEBUG] Failed to get peer status:', e.message);
  }

  const peers = Object.entries(config).filter(([k]) => k.startsWith('Peer'));

  if (peers.length === 0) {
    console.log('  No peers configured');
    return;
  }

  for (const [key, val] of peers) {
    const name = key === 'Peer' ? '(unnamed)' : key.replace('Peer #', '');
    const allowedIPs = val.AllowedIPs || val.AllowedIps || 'N/A';
    const isOnline = onlinePeers.has(val.PublicKey);
    console.log(`  ${isOnline ? '[ONLINE]' : '[OFFLINE]'} ${name}  ${allowedIPs}`);
  }
  console.log('');
}

/**
 * Remove a peer by name
 * @param {string} name - Peer name to remove
 */
async function removePeer(name) {
  await init();

  let config;
  try {
    config = parseWireGuardConfig(readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (e) {
    if (e.code === 'ENOENT') {
      showInitHint();
    } else {
      console.log('[ERROR] Failed to read config: ' + e.message);
    }
    return;
  }
  const peerKey = Object.keys(config).find(k => k === `Peer #${name}` || (config[k] && config[k].PublicKey === name));

  if (!peerKey) {
    console.log(`[ERROR] Peer not found: ${name}`);
    return;
  }

  delete config[peerKey];
  saveConfig(config);
  console.log(`[OK] Removed: ${name}`);
}

/**
 * Show help message
 */
function showHelp() {
  console.log(`
  wgm - Simplified WireGuard Peer Management

  Usage:
    wgm add                        Add a new peer interactively
    wgm list                       List all peers
    wgm rm <name>                  Remove a peer
    wgm -i <name>                  Specify interface (default: auto-detect)
    wgm --dry-run                  Test mode (no sudo/wg required)
    wgm --config <path>            Use custom config file (with --dry-run)

  Examples:
    wgm add
    wgm -i wg1 add
    wgm --dry-run --config ./test.conf add
    wgm list
    wgm rm laptop
    wgm --dry-run --config ./test.conf add  # Test with custom config

  Requirements:
    - WireGuard installed (except in --dry-run mode)
    - Node.js >= 14
    - Root privileges (auto-requested)
  `);
}

/**
 * Main entry point
 */
async function main() {
  // Handle --dry-run and --config flags
  const allArgs = process.argv.slice(2);
  const args = [];
  for (let i = 0; i < allArgs.length; i++) {
    const arg = allArgs[i];
    if (arg === '--dry-run' || arg === '--test') continue;
    if (arg === '--config') {
      i++; // Skip the next argument (config path)
      continue;
    }
    args.push(arg);
  }
  const cmd = args[0];

  if (DRY_RUN) {
    console.log('[DRY-RUN] Running in test mode (no WireGuard required)\n');
  }

  if (cmd === 'add') {
    await addPeer();
  } else if (cmd === 'list' || cmd === 'ls') {
    await listPeers();
  } else if (cmd === 'rm' || cmd === 'remove') {
    const name = args[1];
    if (name) await removePeer(name);
    else console.log('Usage: wgm rm <name>');
  } else if (cmd === '-h' || cmd === '--help' || cmd === '-v' || cmd === '--version') {
    showHelp();
  } else {
    showHelp();
  }
}

main();
